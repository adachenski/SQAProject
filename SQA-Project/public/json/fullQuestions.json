[
    {
        "id": 1,
        "category": "testingTypes",
        "referToId": 19,
        "title": "Functional testing?",
        "content": " <div> <div> Functional testing is a type of testing which verifies that each function of the software application operates in conformance with the requirement specification. This testing mainly involves black box testing and it is not concerned about the source code of the application. Each and every functionality of the system is tested by providing appropriate input, verifying the output and comparing the actual results with the expected results. This testing involves checking of User Interface, APIs, Database, security, client/ server applications and functionality of the Application Under Test. The testing can be done either manually or using automation </div><h3> What do you test in Functional Testing? </h3> <div> The prime objective of Functional testing is checking the functionalities of the software system. It mainly concentrates on </div><div> <b>Mainline functions</b>: Testing the main functions of an application </div><div> <b>Basic Usability</b>: It involves basic usability testing of the system. It checks whether an user can freely navigate through the screens without any difficulties. </div><div> <b>Accessibility</b>: Checks the accessibility of the system for the user </div><div> <b>Error Conditions</b>: Usage of testing techniques to check for error conditions. It checks whether suitable error messages are displayed. </div><div> <ul> <h3>Types of Functional testing</h3> <li>Unit Testing</li><li>Integration Testing</li><li><a href='/questions/152'>Smoke/Sanity</a></li><li>User Acceptance</li><li>Localization</li><li>Globalization</li><li>Interoperability</li><li>So on..</li></ul> </div></div>"
    },
    {
        "id": 2,
        "category": "testingTypes",
        "referToId": 20,
        "title": "Non-functional testing?",
        "content": " <div> <div> Non-functional testing is the testing of a software application or system for its non-functional requirements: the way a system operates, rather than specific behaviours of that system. Like functional testing, there are non-functional requirements like performance, usability, load factor that are also important. Many times you have come across to long load time messages while accessing an application. To address this issue, performance testing is carried out to check & fine tune system response times. The goal of performance testing is to reduce response time to an acceptable level. Likewise, you might have seen the message like 'Server Busy'. Hence, load testing is carried out to check systems performance at different loads i.e. number of users accessing the system. </div><div> <ul> <h4>Types on Non-functional testing</h4> <li>Performance</li><li>Endurance</li><li><a href='/questions/41'>Load</a></li><li>Volume</li><li>Scalability</li><li>Usability</li><li>So on..</li></ul> </div></div>"
    },
    {
        "id": 3,
        "category": "testingTypes",
        "referToId": 25,
        "title": "Ad-hoc testing?",
        "content": " <div> <div> Adhoc testing is an informal testing type with an aim to break the system. This testing is usually an unplanned activity. It does not follow any test design techniques to create test cases. In fact is does not create test cases altogether! This testing is primarily performed if the knowledge of testers in the system under test is very high. Testers randomly test the application without any test cases or any business requirement document. Ad hoc Testing does not follow any structured way of testing and it is randomly done on any part of application. Main aim of this testing is to find defects by random checking. Adhoc testing can be achieved with the testing technique called Error Guessing. Error guessing can be done by the people having enough experience on the system to 'guess' the most likely source of errors. This testing requires no documentation/ planning /process to be followed. Since this testing aims at finding defects through random approach, without any documentation, defects will not be mapped to test cases. Hence, sometimes, it is very difficult to reproduce the defects as there are no test steps or requirements mapped to it. </div><h3>When execute Adhoc Testing?</h3> <div>Ad hoc testing can be performed when there is limited time to do elaborative testing. Usually adhoc testing is performed after the formal test execution. And if time permits, ad hoc testing can be done on the system). Ad hoc testing will be effective only if the tester is knowledgeable of the System Under Test.</div><h3>Types of adhoc testing</h3> <dl> <dt><b>Buddy Testing </b></dt> <dd>Two buddies mutually work on identifying defects in the same module. Mostly one buddy will be from development team and another person will be from testing team. Buddy testing helps the testers develop better test cases and development team can also make design changes early. This testing usually happens after unit testing completion. </dd> <dt><b>Pair testing </b></dt> <dd>Two testers are assigned modules, share ideas and work on the same machines to find defects. One person can execute the tests and another person can take notes on the findings. Roles of the persons can be a tester and scriber during testing.</dd> <dt><b>Monkey Testing </b></dt> <dd>Randomly test the product or application without test cases with a goal to break the system.</dd> </dl> </div>"
    },
    {
        "id": 4,
        "category": "testingTypes",
        "referToId": 35,
        "title": "Smoke testing?",
        "content": "<div>Smoke Testing is a kind of Software Testing performed after software build to ascertain that the critical functionalities of the program is working fine. It is executed 'before' any detailed functional or regression tests are executed on the software build. The purpose is to reject a badly broken application, so that the QA team does not waste time installing and testing the software application.In Smoke Testing, the test cases chosen cover the most important functionality or component of the system. The objective is not to perform exhaustive testing, but to verify that the critical functionalities of the system is working fine.For Example a typical smoke test would be - Verify that the application launches successfully, Check that the GUI is responsive ... etc.</div>"
    },
    {
        "id": 5,
        "category": "testingTypes",
        "referToId": 36,
        "title": "Sanity testing?",
        "content": "<div>Sanity testing is a kind of Software Testing performed after receiving a software build, with minor changes in code, or functionality, to ascertain that the bugs have been fixed and no further issues are introduced due to these changes. The goal is to determine that the proposed functionality works roughly as expected. If sanity test fails, the build is rejected to save the time and costs involved in a more rigorous testing.The objective is 'not' to verify thoroughly the new functionality, but to determine that the developer has applied some rationality (sanity) while producing the software. For instance, if your scientific calculator gives the result of 2 + 2=5! Then, there is no point testing the advanced functionalities like sin 30 + cos 50.</div>"
    },
    {
        "id": 6,
        "category": "documentation",
        "referToId": 68,
        "title": "Test Case?",
        "content": " <div> <p> A test case is a set of conditions or variables under which a tester will determine whether a system under test satisfies requirements or works correctly. The process of developing test cases can also help find problems in the requirements or design of an application. </p><p> TEST CASE TEMPLATE A test case can have the following elements. Note, however, that normally a test management tool is used by companies and the format is determined by the tool used. </p><div> <dl> <dt><b>Test Suite ID</b></dt> <dd>The ID of the test suite to which this test case belongs.</dd> <dt><b>Test Case ID</b></dt> <dd> The ID of the test case.</dd> <dt><b>Test Case Summary</b></dt> <dd>The summary / objective of the test case.</dd> <dt><b>Related Requirement</b></dt> <dd> The ID of the requirement this test case relates/traces to.</dd> <dt><b>Prerequisites</b></dt> <dd>Any prerequisites or preconditions that must be fulfilled prior to executing the test.</dd> <dt><b>Test Procedure</b></dt> <dd> Step-by-step procedure to execute the test.</dd> <dt><b>Test Data</b></dt> <dd>The test data, or links to the test data, that are to be used while conducting the test.</dd> <dt><b>Expected Result</b></dt> <dd> The expected result of the test.</dd> <dt><b>Actual Result</b></dt> <dd>The actual result of the test; to be filled after executing the test.</dd> <dt><b>Status</b></dt> <dd> Pass or Fail. Other statuses can be ‘Not Executed’ if testing is not performed and ‘Blocked’ if testing is blocked. </dd> <dt><b>Created By</b></dt> <dd>The name of the author of the test case.</dd> <dt><b>Executed By</b></dt> <dd> The name of the person who executed the test.</dd> <dt><b>Date of Execution</b></dt> <dd>The date of execution of the test.</dd> <dt><b>Test Environment</b></dt> <dd> The environment (Hardware/Software/Network) in which the test was executed.</dd> </dl> </div><ul> <li>As far as possible, write test cases in such a way that you test only one thing at a time. Do not overlap or complicate test cases. Attempt to make your test cases ‘atomic’.</li><li>Ensure that all positive scenarios and negative scenarios are covered.</li><li>Language: <ul> <li>Write in simple and easy to understand language.</li><li>Use active voice: Do this, do that.</li><li>Use exact and consistent names (of forms, fields, etc).</li></ul> </li><li>Characteristics of a good test case: <ul> <li><em>Accurate</em>: Exacts the purpose.</li><li><em>Economical</em>: No unnecessary steps or words.</li><li><em>Traceable</em>: Capable of being traced to requirements.</li><li><em>Repeatable</em>: Can be used to perform the test over and over.</li><li><em>Reusable</em>: Can be reused if necessary.</li></ul> </li></ul> </div>"
    },
    {
        "id": 7,
        "category": "documentation",
        "referToId": 69,
        "title": "Use Case?",
        "content": " <div><div> <div> <div> <p>A use case is a software and system engineering term that describes how a user uses a system to accomplish a particular goal. A use case acts as a software modeling technique that defines the features to be implemented and the resolution of any errors that may be encountered.</p></div></div></div></div><div> <h2>Techopedia explains <span>Use Case</span></h2> <div> <div> <p>Use cases define interactions between external actors and the system to attain particular goals. There are three basic elements that make up a use case: <br></p><ul> <li>Actors: Actors are the type of users that interact with the system. </li><li>System: Use cases capture functional requirements that specify the intended behavior of the system. </li><li>Goals: Use cases are typically initiated by a user to fulfill goals describing the activities and variants involved in attaining the goal. </li></ul> <p> Use cases are modeled using unified modeling language and are represented by ovals containing the names of the use case. Actors are represented using lines with the name of the actor written below the line. To represent an actor's participation in a system, a line is drawn between the actor and the use case. Boxes around the use case represent the system boundary. <br><br>Characteristics associated with use cases are:<br></p><ul> <li>Organizing functional requirements</li><li>Modeling the goals of system user interactions</li><li>Recording scenarios from trigger events to ultimate goals</li><li>Describing the basic course of actions and exceptional flow of events</li><li>Permitting a user to access the functionality of another event</li></ul> <p> The steps in designing use cases are:<br></p><ul> <li>Identify the users of the system</li><li>For each category of users, create a user profile. This includes all roles played by the users relevant to the system.</li><li>Identify significant goals associated with each role to support the system. The system’s value proposition identifies the significant role.</li><li>Create use cases for every goal associated with a use case template and maintain the same abstraction level throughout the use case. Higher level use case steps are treated as goals for the lower level. </li><li>Structure the use cases</li><li>Review and validate the users</li></ul> </div></div></div>"
    },
    {
        "id": 8,
        "category": "documentation",
        "referToId": 72,
        "title": "Test Matrix?",
        "content": "<div><h4>What is a requirements test matrix?</h4><p>The requirements test matrix is a project management tool for tracking and managing testing efforts, based on requirements, throughout the project's life cycle. The requirements test matrix is a table, where requirement descriptions are put in the rows of the table, and the descriptions of testing efforts are put in the column headers of the same table. </p><p>The requirements test matrix is similar to the requirements traceability matrix, which is a representation of user requirements aligned against system functionality. The requirements traceability matrix ensures that all user requirements are addressed by the system integration team and implemented in the system integration effort. The requirements test matrix is a representation of user requirements aligned against system testing. Similarly to the requirements traceability matrix, the requirements test matrix ensures that all user requirements are addressed by the system test team and implemented in the system testing effort.</p></div>"
    },
    {
        "id": 9,
        "category": "documentation",
        "referToId": 75,
        "title": "Traceability Matrix?",
        "content": " <div> <div><div> <div> <div> A traceability matrix is a type of document that helps correlate and trace business, application, security or any other requirements to their implementation, testing or completion. It evaluates and relates between different system components and provides the status of project requirements in terms of their level of completion.</div></div></div></div><div> <h2><span>Traceability Matrix</span></h2> <div> <div> <p>A traceability matrix is primarily used in software development projects to trace, identify and verify that a specific functionality or component is being developed. Typically, a traceability matrix is a worksheet type document consisting of a table(s). Two different sets of values are compared against each other by placing an identifier for one set in the top row, and the other set on the left column. If there is commonality or a relationship, a mark is placed where the column and row intersect.</p><p>For example, if software being developed is to be evaluated for completion using a traceability matrix, project requirements can be placed within the left column and their pertaining test cases on the top row. If the project requirement and its test case are completed, a mark can be placed where they intersect on the chart, and all of these requirements can be added to calculate software completion status.</p></div></div></div></div>"
    },
    {
        "id": 10,
        "category": "documentation",
        "referToId": 67,
        "title": "Test Plan?",
        "content": "<div>A test plan helps you and your peers get on the same page. It serves as a framework and a guide to ensure your testing project is successful and helps you control risk. The very act of writing helps us think through things in ways we might not think about normally. The value of writing your plan alone is tremendous. These documents serve as a means of communication across the software team. They can also help track changes to the testing project overall. As changes to the test plan are made (items to be tested, resources involved, schedule, etc) the test plan document should be updated to reflect those decisions. There’s no set way of creating a test plan, but there are common suggestions on what to include. </div>"
    },
    {
        "id": 11,
        "category": "mobile",
        "referToId": 142,
        "title": "Android Arhitecture?",
        "content": " <div> <h2>Linux kernel</h2> <p>At the bottom of the layers is Linux - Linux 3.6 with approximately 115 patches. This provides a level of abstraction between the device hardware and it contains all the essential hardware drivers like camera, keypad, display etc. Also, the kernel handles all the things that Linux is really good at such as networking and a vast array of device drivers, which take the pain out of interfacing to peripheral hardware.</p><h2>Libraries</h2> <p>On top of Linux kernel there is a set of libraries including open-source Web browser engine WebKit, well known library libc, SQLite database which is a useful repository for storage and sharing of application data, libraries to play and record audio and video, SSL libraries responsible for Internet security etc.</p><h2>Android Libraries</h2> <p>This category encompasses those Java-based libraries that are specific to Android development. Examples of libraries in this category include the application framework libraries in addition to those that facilitate user interface building, graphics drawing and database access. A summary of some key core Android libraries available to the Android developer is as follows −</p><ul class='list'> <li> <p><b>android.app</b> − Provides access to the application model and is the cornerstone of all Android applications.</p></li><li> <p><b>android.content</b> − Facilitates content access, publishing and messaging between applications and application components. </p></li><li> <p><b>android.database</b> − Used to access data published by content providers and includes SQLite database management classes.</p></li><li> <p><b>android.opengl</b> − A Java interface to the OpenGL ES 3D graphics rendering API.</p></li><li> <p><b>android.os</b> − Provides applications with access to standard operating system services including messages, system services and inter-process communication.</p></li><li> <p><b>android.text</b> − Used to render and manipulate text on a device display.</p></li><li> <p><b>android.view</b> − The fundamental building blocks of application user interfaces.</p></li><li> <p><b>android.widget</b> − A rich collection of pre-built user interface components such as buttons, labels, list views, layout managers, radio buttons etc.</p></li><li> <p><b>android.webkit</b> − A set of classes intended to allow web-browsing capabilities to be built into applications. </p></li></ul> <p>Having covered the Java-based core libraries in the Android runtime, it is now time to turn our attention to the C/C++ based libraries contained in this layer of the Android software stack.</p><h2>Android Runtime</h2> <p>This is the third section of the architecture and available on the second layer from the bottom. This section provides a key component called <b>Dalvik Virtual Machine</b> which is a kind of Java Virtual Machine specially designed and optimized for Android.</p><p>The Dalvik VM makes use of Linux core features like memory management and multi-threading, which is intrinsic in the Java language. The Dalvik VM enables every Android application to run in its own process, with its own instance of the Dalvik virtual machine.</p><p>The Android runtime also provides a set of core libraries which enable Android application developers to write Android applications using standard Java programming language.</p><h2>Application Framework</h2> <p>The Application Framework layer provides many higher-level services to applications in the form of Java classes. Application developers are allowed to make use of these services in their applications.</p><p>The Android framework includes the following key services −</p><ul class='list'> <li> <p><b>Activity Manager</b> − Controls all aspects of the application lifecycle and activity stack.</p></li><li> <p><b>Content Providers</b> − Allows applications to publish and share data with other applications.</p></li><li> <p><b>Resource Manager</b> − Provides access to non-code embedded resources such as strings, color settings and user interface layouts.</p></li><li> <p><b>Notifications Manager</b> − Allows applications to display alerts and notifications to the user.</p></li><li> <p><b>View System</b> − An extensible set of views used to create application user interfaces.</p></li></ul> <h2>Applications</h2> <p>You will find all the Android application at the top layer. You will write your application to be installed on this layer only. Examples of such applications are Contacts Books, Browser, Games etc.</p><hr> </div>"
    },
    {
        "id": 12,
        "category": "mobile",
        "referToId": 143,
        "title": "IOS Arhitecture?",
        "content": " <div class='container'> <div class='row'> <div class='col-md-6 col-sm-6'> <div> <h1>iOS Architecture </h1> <p><strong>1. Core OS Layer:</strong></p><p>The Core OS layer holds the low level features that most other technologies are built upon.</p><ul> <li>Core Bluetooth Framework.</li><li>Accelerate Framework.</li><li>External Accessory Framework.</li><li>Security Services framework.</li><li>Local Authentication framework.</li></ul> <p>64-Bit support from IOS7 supports the 64 bit app development and enables the application to run faster.</p><p>&nbsp;</p><p><strong>2. Core Services Layer</strong></p><p>Some of the Important Frameworks available in the core services layers are detailed:</p><ul> <li><strong>Address book framework </strong>– Gives programmatic access to a contacts database of user.</li></ul> <ul> <li><strong>Cloud Kit framework </strong>– Gives a medium for moving data between your app and iCloud.</li></ul> <ul> <li><strong>Core data Framework –</strong> Technology for managing the data model of a Model View Controller app. </li></ul> <ul> <li><strong>Core Foundation framework –</strong> Interfaces that gives fundamental data management and service features for iOS apps.</li></ul> <ul> <li><strong>Core Location framework –</strong> Gives location and heading information to apps.</li></ul> <ul> <li><strong>Core Motion Framework –</strong> Access all motion based data available on a device. Using this core motion framework Accelerometer based information can be accessed.</li></ul> <ul> <li><strong>Foundation Framework –</strong> Objective C covering too many of the features found in the Core Foundation framework</li></ul> <ul> <li><strong>Healthkit framework –</strong> New framework for handling health-related information of user</li></ul> <ul> <li><strong>Homekit framework –</strong> New framework for talking with and controlling connected devices in a user’s home.</li></ul> <ul> <li><strong>Social framework –</strong> Simple interface for accessing the user’s social media accounts.</li></ul> <ul> <li><strong>StoreKit framework –</strong> Gives support for the buying of content and services from inside your iOS apps, a feature known asIn-App Purchase.</li></ul> <p><strong>3. Media Layer: </strong>Graphics, Audio and Video technology is enabled using the Media Layer.</p><p><strong>&nbsp;</strong><strong>Graphics Framework</strong>:</p><ul> <li><strong>UIKit Graphics –</strong> It describes high level support for designing images and also used for animating the content of your views.</li></ul> <ul> <li><strong>Core Graphics framework –</strong> It is the native drawing engine for iOS apps and gives support for custom 2D vector and image based rendering.</li></ul> <ul> <li><strong>Core Animation –</strong> It is an initial technology that optimizes the animation experience of your apps.</li></ul> <ul> <li><strong>Core Images –</strong> gives advanced support for controling video and motionless images in a nondestructive way</li></ul> <ul> <li><strong>OpenGl ES and GLKit –</strong> manages advanced 2D and 3D rendering by hardware accelerated interfaces </li></ul> <ul> <li><strong>Metal –</strong> It permits very high performance for your sophisticated graphics rendering and computation works. It offers very low overhead access to the A7 GPU.</li></ul> <p><strong>Audio Framework:</strong></p><ul> <li><strong>Media Player Framework –</strong> It is a high level framework which gives simple use to a user’s iTunes library and support for playing playlists.</li></ul> <ul> <li><strong>AV Foundation –</strong> It is an Objective C interface for handling the recording and playback of audio and video.</li></ul> <ul> <li><strong>OpenAL –</strong> is an industry standard technology for providing audio.</li></ul> <p>&nbsp;</p><p><strong>Video Framework</strong></p><ul> <li><strong>AV Kit –</strong> framework gives a collection of easy to use interfaces for presenting video.</li></ul> <ul> <li><strong>AV Foundation –</strong> gives advanced video playback and recording capability.</li></ul> <ul> <li><strong>Core Media –</strong> framework describes the low level interfaces and data types for operating media. </li></ul> <p>&nbsp;</p><p><strong>Cocoa Touch Layer</strong></p><ul> <li><strong>EventKit framework –</strong> gives view controllers for showing the standard system interfaces for seeing and altering calendar related events</li></ul> <ul> <li><strong>GameKit Framework –</strong> implements support for Game Center which allows users share their game related information online</li></ul> <ul> <li><strong>iAd Framework –</strong> allows you deliver banner-based advertisements from your app.</li></ul> <ul> <li><strong>MapKit Framework –</strong> gives a scrollable map that you can include into your user interface of app.</li></ul> <ul> <li><strong>PushKitFramework –</strong> provides registration support for VoIP apps.</li></ul> <ul> <li><strong>Twitter Framework –</strong> supports a UI for generating tweets and support for creating URLs to access the Twitter service.</li></ul> <ul> <li><strong>UIKit Framework –</strong> gives vital infrastructure for applying graphical, event-driven apps in iOS. Some of the Important functions of UI Kit framework:</li></ul> <p>-Multitasking support.</p><p>– Basic app management and infrastructure.</p><p>– User interface management</p><p>– Support for Touch and Motion event.</p><p>– Cut, copy and paste support and many more.</p></div></div></div></div>"
    },
    {
        "id": 13,
        "category": "mobile",
        "referToId": 146,
        "title": "What is ADB in Android Studio?",
        "content": " <div> <div> ADB is a client-server program that includes three components: </div><div> A <b>client</b>, which sends commands. The client runs on your development machine. You can invoke a client from a shell by issuing an adb command. Other Android tools such as DDMS also create adb clients. </div><div> A <b>daemon</b>, which runs commands on a device. The daemon runs as a background process on each emulator or device instance. </div><div> A <b>server</b>, which manages communication between the client and the daemon. The server runs as a background process on your development machine. </div></div>"
    },
    {
        "id": 14,
        "category": "mobile",
        "referToId": 151,
        "title": "Types of Mobile App Testing?",
        "content": " <div> <ul> <h4>Functional Testing</h4> <li> Verifying that all documented requirements are implemented.</li><li>Verifying that all features work as expected.</li><li> Validating texts, logos, images, text captions and other UI elements.</li><li>Validating localization and globalization.</li><li> Evaluating ease of navigation and screen transitions. </li><li>Examining response speed.</li><li> Evaluating the intuitiveness of the touch interface.</li></ul> <ul> <h4>Performance Testing</h4> <li>Performance with low battery power </li><li> Performance while network out of coverage area </li><li> Performance during poor bandwidth </li><li> Performance while changing internet connection mode </li><li> Performance while transferring heavy file </li><li> Testing from Application’s server and client side</li></ul> <ul> <h4>Memory Leakage Testing</h4> <li>Verifying if program runs for an extended time and consumes additional memory </li><li> Verifying if memory is allocated frequently for one-time tasks </li><li> Verifying where the program can request memory — such as shared memory that is not released </li><li> Verifying where memory is very limited, such as in an embedded system or portable device </li><li> Verifying where the leak occurs within the operating system or memory manager </li><li> Verifying when a system device driver causes the leak </li></ul> <ul> <h4>Interrupt Testin</h4> <li>Battery low </li><li>Battery full- when charging</li><li> Incoming phone call </li><li> Incoming SMS </li><li> Incoming Alert from another mobile application </li><li> Plugged in for charging </li><li> Plugged out from charging </li><li> Device shut off </li><li> Alarm </li><li> Network connection loss </li><li> Network connection restoration </li><li>Application Update reminders</li></ul> <ul> <h4>Usability Testing</h4> <li>To ensure that the buttons should have the required size and be suitable to big fingers. </li><li> To ensure that the buttons are placed in the same section of the screen to avoid confusion to the end users. </li><li> To ensure that the icons are natural and consistent with the application. </li><li> To ensure that the buttons, which have the same function should also have the same color. </li><li> To ensure that the validation for the tapping zoom-in and zoom-out facilities should be enabled. </li><li> To ensure that the keyboard input can be minimized in an appropriate manner. </li><li> To ensure that the application provides a method for going back or undoing an action, on touching the wrong item, within an acceptable duration. </li><li> To ensure that the contextual menus are not overloaded because it has to be used quickly. </li></ul> <ul> <h4>Instalation Testing</h4> <li>Verify application gets installed properly </li><li>Verify user can uninstall application successfully </li><li> Verify app updates are properly installed </li><li> Verify aborting installation does not affect other features </li><li>Check app behavior on trying to install it on non-supported version/device. </li><li>Verify app is installed properly from app store and from side loading </li></ul> <ul> <h4>Security Testing</h4> <li>Data flow -- Can you establish an audit trail for data, what goes where, is data in transit protected, and who has access to it? </li><li> Data storage -- Where is data stored, and is it encrypted? Cloud solutions can be a weak link for data security. </li><li> Data leakage -- Is data leaking to log files, or out through notifications? </li><li> Authentication -- When and where are users challenged to authenticate, how are they authorized, and can you track password and IDs in the system? </li><li> Server-side controls -- Don't focus on the client side and assume that the back end is secure. </li><li> Points of entry -- Are all potential client-side routes into the application being validated? </li></ul> </div>"
    },
    {
        "id": 15,
        "category": "testingTypes",
        "referToId": 152,
        "title": "Smoke VS Sanity?",
        "content": "<div> <div class='row'> <div class='col-xs-6'> <h4>Smoke Testing</h4> Smoke Testing is performed to ascertain that the critical functionalities of the program is working fine. <hr> The objective of this testing is to verify the 'stability' of the system in order to proceed with more rigorous testing. <hr> This testing is performed by the developers or testers. <hr> Smoke testing is usually documented or scripted. <hr> Smoke testing is a subset of Regression testing. <hr> Smoke testing exercises the entire system from end to end. <hr> Smoke testing is like General Health Check Up. <hr> </div><div class='col-xs-6'> <h4>Smoke Testing</h4> Sanity Testing is done to check the new functionality / bugs have been fixed. <hr> The objective of the testing is to verify the 'rationality' of the system in order to proceed with more rigorous testing. <hr> Sanity testing is usually performed by testers. <hr> Sanity testing is usually not documented and is unscripted. <hr> Sanity testing is a subset of Acceptance testing. <hr> Sanity testing exercises only the particular component of the entire system. <hr> Sanity Testing is like specialized health check up. <hr> </div></div></div>"
    },
    {
        "id": 16,
        "category": "mobil",
        "referToId": 112,
        "title": "What is OWASP?",
        "content": " <div> <ul> <h4> OWASP Top Ten: </h4> <li>Activity monitoring and data retrieval.</li><li>Unauthorized dialing, SMS and payments.</li><li>Unauthorized network connectivity.</li><li>UI impersonation.</li><li>System modification (rootkit, APN proxy config).</li><li>Logic or time bomb.</li><li>Sensitive data leakage (inadvertent or side channel).</li><li>Unsafe sensitive data storage.</li><li>Unsafe sensitive data transmission.</li><li>Hardcoded password/keys.</li></ul> <div> The Top Ten was first published in 2003 and is regularly updated. Its goal is to raise awareness about application security by identifying some of the most critical risks facing organizations. The Top 10 project is referenced by many standards, books, tools, and organizations, including MITRE, PCI DSS, Defense Information Systems Agency, FTC, and many more. </div></div>"
    },
    {
        "id": 17,
        "category": "testingTypes",
        "referToId": 41,
        "title": "Load Testing?",
        "content": "<div> Load testing is the process of putting demand on a software system or computing device and measuring its response. Load testing is performed to determine a system's behavior under both normal and anticipated peak load conditions. It helps to identify the maximum operating capacity of an application as well as any bottlenecks and determine which element is causing degradation. When the load placed on the system is raised beyond normal usage patterns to test the system's response at unusually high or peak loads, it is known as stress testing. The load is usually so great that error conditions are the expected result, but there is no clear boundary when an activity ceases to be a load test and becomes a stress test. The term 'load testing' is often used synonymously with concurrency testing, software performance testing, reliability testing, and volume testing. All of these are types of <a href='/questions/20'>non-functional</a> testing that are part of functionality testing used to validate suitability for use of any given software. </div>"
    },
    {
        "id": 18,
        "category": "testingTypes",
        "referToId": 38,
        "title": "Alpha Testing?",
        "content": "<div>Alpha testing is a type of acceptance testing; performed to identify all possible issues/bugs before releasing the product to everyday users or public.  The focus of this testing is to simulate real users by using blackbox and whitebox techniques. The aim is to carry out the tasks that a typical user might perform. Alpha testing is carried out in a lab environment and usually the testers are internal employees of the organization. To put it as simple as possible, this kind of testing is called alpha only because it is done early on, near the end of the development of the software, and before <a href='/questions/39'>Beta Testing.<a></div>"
    },
    {
        "id": 19,
        "category": "testingTypes",
        "referToId": 39,
        "title": "Beta Testing?",
        "content": "<div>Beta Testing of a product is performed by 'real users' of the software application in a 'real environment' and can be considered as a form of external User Acceptance Testing. Beta version of the software is released to a limited number of end-users of the product to obtain feedback on the product quality. Beta testing reduces product failure risks and provides increased quality of the product through customer validation. It is the final test before shipping a product to the customers. Direct feedback from customers is a major advantage of Beta Testing. This testing helps to tests the product in real time environment.</div>"
    },
    {
        "id": 20,
        "category": "testingTypes",
        "referToId": 28,
        "title": "System Testing?",
        "content": " <div> System testing is the type of testing to check the behaviour of a complete and fully where to buy generic modafinil integrated software product based on the software requirements specification (SRS) document. The main focus of this testing is to evaluate Business / Functional / End-user requirements. This is black box type of testing where external working of the software is evaluated with the help of requirement documents & it is totally based on Users point of view. For this type of testing do not required knowledge of internal design or structure or code. This testing is to be carried out only after System Integration Testing is completed where both <a href='/questions/19'>Functional</a> & <a href='/questions/20'>Non-Functional</a> requirements are verified. In the integration testing testers are concentrated on finding bugs/defects on integrated modules. But in the Software System Testing testers are concentrated on finding bugs/defects based on software application behavior, software design and expectation of end user. </div>"
    }
]